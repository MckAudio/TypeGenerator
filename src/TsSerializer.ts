import { ISerializer, SerializerData, SerializerDataArray } from "./ISerializer";
import { GetTsDefault, GetTsType } from "./SerializerTools";
import { GetDate } from "./tools";
import { ArrayType, ClassType, Dictionary, DictType, EnumDefinition, EnumType, LinkType, SimpleType } from "./types";
import path from "path";

export class TsSerializer extends ISerializer {
    protected deps = new Set<string>();
    constructor(fileName: string, author: string, namespace?: Array<string>) {
        super(fileName, author, "ts", namespace);
    }

    protected begin() {
        this.store.header = `/**\n * @file ${this.fileName}.${this.extension}\n`;
        this.store.header += ` * @author ${this.author}\n * @brief Autogenerated by MckAudio TypeGenerator\n`;
        this.store.header += ` * @link https://github.com/MckAudio/TypeGenerator\n`;
        this.store.header += ` */\n\n`;
        this.store.header += "interface Dictionary<Type> {\n\t[name: string]: Type\n}\n";
    }

    protected end() {
        this.deps.forEach(dep => {
            this.store.header += `import * as ${dep} from \"./${dep}\";\n`;
        });
        this.store.header += `\n`;
    }

    addEnumDefinition(name: string, member: EnumDefinition): void {
        let tmp = new SerializerData();
        tmp.sortId = this.sortId++;
        tmp.header = `${this.indent}export enum ${name} {\n`;
        Object.entries(member.items).forEach(e => {
            tmp.content += `${this.indent}\t${e[0]} = ${e[1]},\n`;
        })
        tmp.footer = `${this.indent}}\n\n`;

        this.enums[name] = tmp;
    }

    addClassMember(name: string, member: ClassType) {
        this.classes[name] = new SerializerDataArray();
        let cl = this.classes[name];

        let tmp = new SerializerData();
        tmp.sortId = this.sortId++;
        cl.createMember();
        cl.addToHeader(0, `${this.indent}export class ${name} `);
        if (member.parent !== undefined) {
            cl.addToHeader(0, `extends ${member.parent} `);
        }
        cl.addToHeader(0, `{\n`);

        cl.createMember();
        cl.addToHeader(1, `${this.indent}\tconstructor(props?: Dictionary<any>) {\n`);
        if (member.parent !== undefined) {
            cl.addToHeader(1, `${this.indent}\t\tsuper(props);\n`);
        }
        cl.addToContent(1, `${this.indent}\t\tif (props !== undefined) {\n`);
        cl.addToContent(1, `${this.indent}\t\t\tObject.entries(props).forEach(p => {\n`);
        cl.addToContent(1, `${this.indent}\t\t\t\tif (this.hasOwnProperty(p[0])) {\n`);
        cl.addToContent(1, `${this.indent}\t\t\t\t\tthis[p[0]] = p[1];\n`);
        cl.addToContent(1, `${this.indent}\t\t\t\t}\n`);
        cl.addToContent(1, `${this.indent}\t\t\t});\n`);
        cl.addToContent(1, `${this.indent}\t\t}\n`);
        cl.addToFooter(1, `${this.indent}\t}\n`);

        // Static Dictionary of default values
        cl.createMember();
        cl.addToHeader(2, `${this.indent}\tprivate static ${name}_default_values: Dictionary<number | boolean | string> = {\n`);
        cl.addToFooter(2, `${this.indent}\t}\n`);

        // Static Dictionary of minimum values
        cl.createMember();
        cl.addToHeader(3, `${this.indent}\tprivate static ${name}_minimum_values: Dictionary<number> = {\n`);
        cl.addToFooter(3, `${this.indent}\t}\n`);

        // Static Dictionary of maximum values
        cl.createMember();
        cl.addToHeader(4, `${this.indent}\tprivate static ${name}_maximum_values: Dictionary<number> = {\n`);
        cl.addToFooter(4, `${this.indent}\t}\n`);

        // Static Function to retrieve the default values
        cl.createMember();
        cl.addToHeader(5, `${this.indent}\tstatic get_default_value(key: string): number | boolean | string | undefined {\n`);
        if (member.parent !== undefined) {
            cl.addToContent(5, `${this.indent}\t\tlet ret = super.get_default_value(key);\r`)
            cl.addToContent(5, `${this.indent}\t\tif (ret === undefined && this.${name}_default_values.hasOwnProperty(key)) {\n`);
        } else {
            cl.addToContent(5, `${this.indent}\t\tlet ret = undefined;\r`)
            cl.addToContent(5, `${this.indent}\t\tif (this.${name}_default_values.hasOwnProperty(key)) {\n`);
        }
        cl.addToContent(5, `${this.indent}\t\t\tret = this.${name}_default_values[key];\n`);
        cl.addToContent(5, `${this.indent}\t\t}\n`);
        cl.addToContent(5, `${this.indent}\t\treturn ret;\n`);
        cl.addToFooter(5, `${this.indent}\t}\n`);

        // Static Function to retrieve the minimum values
        cl.createMember();
        cl.addToHeader(6, `${this.indent}\tstatic get_minimum_value(key: string): number | undefined {\n`);
        if (member.parent !== undefined) {
            cl.addToContent(6, `${this.indent}\t\tlet ret = super.get_minimum_value(key);\r`)
            cl.addToContent(6, `${this.indent}\t\tif (ret === undefined && this.${name}_minimum_values.hasOwnProperty(key)) {\n`);
        } else {
            cl.addToContent(6, `${this.indent}\t\tlet ret = undefined;\r`)
            cl.addToContent(6, `${this.indent}\t\tif (this.${name}_minimum_values.hasOwnProperty(key)) {\n`);
        }
        cl.addToContent(6, `${this.indent}\t\t\tret = this.${name}_minimum_values[key];\n`);
        cl.addToContent(6, `${this.indent}\t\t}\n`);
        cl.addToContent(6, `${this.indent}\t\treturn ret;\n`);
        cl.addToFooter(6, `${this.indent}\t}\n`);

        // Static Function to retrieve the maximum values
        cl.createMember();
        cl.addToHeader(7, `${this.indent}\tstatic get_maximum_value(key: string): number | undefined {\n`);
        if (member.parent !== undefined) {
            cl.addToContent(7, `${this.indent}\t\tlet ret = super.get_maximum_value(key);\r`)
            cl.addToContent(7, `${this.indent}\t\tif (ret === undefined && this.${name}_maximum_values.hasOwnProperty(key)) {\n`);
        } else {
            cl.addToContent(7, `${this.indent}\t\tlet ret = undefined;\r`)
            cl.addToContent(7, `${this.indent}\t\tif (this.${name}_maximum_values.hasOwnProperty(key)) {\n`);
        }
        cl.addToContent(7, `${this.indent}\t\t\tret = this.${name}_maximum_values[key];\n`);
        cl.addToContent(7, `${this.indent}\t\t}\n`);
        cl.addToContent(7, `${this.indent}\t\treturn ret;\n`);
        cl.addToFooter(7, `${this.indent}\t}\n`);

        cl.addToFooter(7, `${this.indent}}\n\n`);
    }

    addSimpleMember(className: string, name: string, member: SimpleType) {
        let cl = this.classes[className];
        let defString = "";
        if (member.default !== undefined) {
            if (member.type === "string") {
                defString = `\"${member.default}\"`;
            } else {
                defString = `${member.default}`;
            }
        } else {
            defString = `${GetTsDefault(member)}`;
        }
        cl.addToContent(0, `${this.indent}\t${name}: ${GetTsType(member)} = ${defString};\n`);
        cl.addToContent(2, `${this.indent}\t\t\"${name}\": ${defString},\n`);
        if (member.minimum !== undefined) {
            cl.addToContent(3, `${this.indent}\t\t\"${name}\": ${member.minimum},\n`);
        }
        if (member.maximum !== undefined) {
            cl.addToContent(4, `${this.indent}\t\t\"${name}\": ${member.maximum},\n`);
        }
    }

    addLinkMember(className: string, name: string, member: LinkType) {
        let tmp = `${this.indent}\t${name}: ${GetTsType(member)} = ${GetTsDefault(member)};\n`;
        if (member.file !== undefined) {
            let bn = path.basename(member.file, path.extname(member.file));
            tmp = `${this.indent}\t${name}: ${bn}.${GetTsType(member)} = ${GetTsDefault(member, bn)};\n`;
            this.deps.add(`${bn}`);
        }
        this.classes[className].addToContent(0, tmp);
    }

    addArrayMember(className: string, name: string, member: ArrayType) {
        if (member.items.type === "array") {
            let type = GetTsType(member.items.items);
            let tmp = `${this.indent}\t${name}: Array<Array<${type}>> = [];\n`;
            if (member.items.items.hasOwnProperty('file')) {
                let file = (member.items.items as LinkType).file;
                if (file !== undefined) {
                    let bn = path.basename(file, path.extname(file));
                    tmp = `${this.indent}\t${name}: Array<Array<${bn}.${GetTsType(member.items)}>> = [];\n`;
                    this.deps.add(`${bn}`);
                }
            }
            this.classes[className].addToContent(0, tmp);
        } else {
            let type = GetTsType(member.items);
            let tmp = `${this.indent}\t${name}: Array<${type}> = [];\n`;
            if (member.items.hasOwnProperty('file')) {
                let file = (member.items as LinkType).file;
                if (file !== undefined) {
                    let bn = path.basename(file, path.extname(file));
                    tmp = `${this.indent}\t${name}: Array<${bn}.${type}> = [];\n`;
                    this.deps.add(`${bn}`);
                }
            }
            this.classes[className].addToContent(0, tmp);
        }
    }

    addEnumMember(className: string, name: string, member: EnumType): void {
        let tmp = `${this.indent}\t${name}: ${GetTsType(member)} = ${GetTsDefault(member)};\n`;
        this.classes[className].addToContent(0, tmp);
    }

    addDictMember(className: string, name: string, member: DictType): void {
        let type = GetTsType(member.items);
        let tmp = `${this.indent}\t${name}: Dictionary<${type}> = {};\n`;
        if (member.items.hasOwnProperty('file')) {
            let file = (member.items as LinkType).file;
            if (file !== undefined) {
                let bn = path.basename(file, path.extname(file));
                tmp = `${this.indent}\t${name}: Dictionary<${bn}.${type}> = {};\n`;
                this.deps.add(`${bn}`);
            }
        }
        this.classes[className].addToContent(0, tmp);
    }
}